<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Video2ASCII â€” Final Local Build</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>
  body {
    background:#000;
    color:#0f0;
    font-family:monospace;
    text-align:center;
    margin:0;
    padding:1em;
  }
  h1, h2{margin:0.2em 0;}
  .controls{
    display:flex;flex-wrap:wrap;justify-content:center;gap:0.5em;margin-bottom:1em;
  }
  label{color:#0f0;}
  input,select,button{
    background:#111;color:#0f0;border:1px solid #0f0;
    font-family:monospace;padding:0.3em 0.6em;
  }
  button:hover,input:hover,select:hover{background:#0f0;color:#000;}
  video{max-width:45%;border:1px solid #0f0;}
  pre{
    display:inline-block;background:#000;color:#0f0;border:1px solid #0f0;
    white-space:pre;line-height:0.6em;font-size:10px;text-align:center;
    overflow:hidden;max-width:45%;
  }
  #ascii-canvas {
    display:block;background:#000;border:1px solid #0f0;max-width:45%;
  }
  .display{display:flex;justify-content:center;align-items:flex-start;gap:1em;flex-wrap:wrap;}
  #status{margin-top:0.5em;color:#0f0;}
  .rainbow {
    background: linear-gradient(to right, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #8f00ff);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent !important;
  }
</style>
</head>
<body>
<h1>ðŸŽ¥ Video â†’ ASCII</h1>

<div class="controls">
  <input type="file" id="file" accept="video/mp4,video/webm">
  <label>Width:<input type="number" id="width" value="100" min="40" max="200"></label>
  <label>FPS:<input type="number" id="fps" value="15" min="5" max="60"></label>
  <label>Font:<input type="number" id="fontsize" value="10" min="6" max="20"></label>
  <label>Color Scheme:
    <select id="scheme">
      <option value="matrix">Matrix Green</option>
      <option value="cyber">Cyberpunk Neon</option>
      <option value="amber">Retro Amber</option>
      <option value="pastel">Soft Pastel</option>
      <option value="rainbow">Rainbow</option>
      <option value="custom" hidden disabled>Custom</option>
    </select>
  </label>
  <label>BG:<input type="color" id="bg" value="#000000"></label>
  <label>Text:<input type="color" id="txt" value="#00ff00"></label>
  <label>Effect:
    <select id="fx">
      <option value="none">None</option>
      <option value="matrix">Matrix Rain</option>
      <option value="glitch">Glitch</option>
      <option value="oldtv">Old TV</option>
    </select>
  </label>
  <label>Resolution:
    <select id="resolution">
      <option value="dynamic">Window</option>
      <option value="480p">480p</option>
      <option value="720p">720p</option>
      <option value="1080p">1080p</option>
    </select>
  </label>
  <label>Keep Audio:<input type="checkbox" id="keep-audio"></label>
  <button id="start">Convert</button>
  <button id="record">Record</button>
  <button id="stop">Stop</button>
</div>

<h2>ðŸ¤– AI ASCII Art Generator</h2>
<div class="controls">
  <input type="text" id="ai-prompt" placeholder="Enter text prompt..." style="width: 200px;">
  <select id="ai-style">
    <option value="">Default Style</option>
    <option value="minimalist line art">Minimalist</option>
    <option value="highly detailed, intricate">Detailed</option>
    <option value="cyberpunk, neon">Cyberpunk</option>
    <option value="retro computer graphics, 8-bit">Retro</option>
    <option value="sketch, pencil drawing">Sketch</option>
  </select>
  <button id="ai-generate">Generate AI Art</button>
  <button id="ai-download" style="display:none;">Download Text</button>
</div>

<div class="controls" id="ai-settings">
  <label>Provider:
    <select id="ai-provider">
      <option value="pollinations">Pollinations (Free)</option>
      <option value="openai">OpenAI (API Key)</option>
      <option value="mock">Mock (Test)</option>
    </select>
  </label>
  <input type="password" id="ai-api-key" placeholder="API Key (OpenAI)" style="display:none; width: 200px;">
  <label><input type="checkbox" id="ai-enhance" checked> Enhance Prompt</label>
</div>
<div id="ai-status-detail" style="color: #0f0; font-size: 0.8em; margin-bottom: 0.5em;"></div>

<div class="display">
  <video id="video" controls></video>
  <pre id="ascii" style="display:none;"></pre>
  <canvas id="ascii-canvas"></canvas>
</div>
<canvas id="canvas" style="display:none;"></canvas>
<canvas id="recording-canvas" style="display:none;"></canvas>
<p id="status"></p>

<!-- ffmpeg.wasm CDN -->
<script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>

<script>
const { createFFmpeg, fetchFile } = FFmpeg;
const chars="@#8&$%WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~<>i!lI;:,\"^`'. ";

// DOM Elements
const file = document.getElementById('file');
const vid = document.getElementById('video');
const can = document.getElementById('canvas');
const recordingCan = document.getElementById('recording-canvas');
const ctx = can.getContext('2d');
const recordingCtx = recordingCan.getContext('2d');
const asciiOut = document.getElementById('ascii');
const asciiCanvas = document.getElementById('ascii-canvas');
const asciiCtx = asciiCanvas.getContext('2d');
const resolution = document.getElementById('resolution');
const start = document.getElementById('start');
const stop = document.getElementById('stop');
const recBtn = document.getElementById('record');
const status = document.getElementById('status');
const schemeSelect = document.getElementById('scheme');
const bgInput = document.getElementById('bg');
const txtInput = document.getElementById('txt');
const widthInput = document.getElementById('width');
const fpsInput = document.getElementById('fps');
const fontInput = document.getElementById('fontsize');
const keepAudio = document.getElementById('keep-audio');
const fxSelect = document.getElementById('fx');

// AI Elements
const aiPrompt = document.getElementById('ai-prompt');
const aiStyle = document.getElementById('ai-style');
const aiGenerate = document.getElementById('ai-generate');
const aiDownload = document.getElementById('ai-download');
const aiProvider = document.getElementById('ai-provider');
const aiApiKey = document.getElementById('ai-api-key');
const aiEnhance = document.getElementById('ai-enhance');
const aiStatusDetail = document.getElementById('ai-status-detail');

let running = false;
let recorder = null;
let chunks = [];
let stream = null;
let effectState = {
  matrix: { drops: [] },
  glitch: { timer: 0 },
  oldtv: { offset: 0 }
};

const schemes = {
  matrix: { bg: "#000000", txt: "#00ff00" },
  cyber: { bg: "#000000", txt: "#00ffff" },
  amber: { bg: "#000000", txt: "#ffb000" },
  pastel: { bg: "#282828", txt: "#ffb6c1" },
  rainbow: { bg: "#000000", txt: "#ffffff" }
};

// Event Listeners
schemeSelect.onchange = () => {
  const s = schemes[schemeSelect.value];
  if (s) {
    bgInput.value = s.bg;
    txtInput.value = s.txt;
  }
};

[bgInput, txtInput].forEach(el => {
  el.addEventListener('input', () => {
    schemeSelect.value = 'custom';
  });
});

aiProvider.onchange = () => {
  if (aiProvider.value === 'openai') {
    aiApiKey.style.display = 'inline-block';
  } else {
    aiApiKey.style.display = 'none';
  }
};

file.onchange = e => {
  const f = e.target.files[0];
  if (f) {
    vid.src = URL.createObjectURL(f);
    vid.load();
    status.textContent = "Video loaded";
  }
};

start.onclick = () => {
  if (!vid.src) return alert("Load a video");
  running = true;
  vid.play();
  renderLoop();
};

stop.onclick = () => {
  running = false;
  vid.pause();
  if (recorder && recorder.state === "recording") recorder.stop();
  status.textContent = "Stopped.";
};

function frameToASCII(frame){
  const p=frame.data,w=frame.width,h=frame.height;let out="";
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i=(y*w+x)*4;
      const r=p[i],g=p[i+1],b=p[i+2];
      const bright=(0.299*r+0.587*g+0.114*b)/255;
      const idx=Math.floor((1-bright)*(chars.length-1));
      out+=chars[idx];
    }
    out+="\n";
  }
  return out;
}

async function enhancePrompt(prompt, provider, key) {
  if (provider === 'mock') return "Enhanced (Mock): " + prompt;
  if (provider === 'openai') {
    if (!key) throw new Error("API Key required for OpenAI");
    const res = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${key}`
      },
      body: JSON.stringify({
        model: "gpt-3.5-turbo",
        messages: [{role: "user", content: "Enhance this prompt for an AI image generator: " + prompt}],
        max_tokens: 100
      })
    });
    const data = await res.json();
    if (data.error) throw new Error(data.error.message);
    return data.choices[0].message.content.trim();
  }
  // Default Pollinations
  try {
      const res = await fetch(`https://text.pollinations.ai/${encodeURIComponent(prompt)}`);
      if (!res.ok) throw new Error("Pollinations text API error");
      return await res.text();
  } catch (e) {
      console.warn("Pollinations text failed, using original", e);
      return prompt;
  }
}

aiGenerate.onclick = async () => {
    const prompt = aiPrompt.value.trim();
    if (!prompt) return alert("Please enter a prompt");

    if (running) {
         running = false;
         vid.pause();
         status.textContent = "Video stopped for AI generation.";
    }

    status.textContent = "Initializing AI generation...";
    asciiOut.textContent = "Initializing AI generation...";
    aiDownload.style.display = 'none';

    // Clear canvases
    ctx.clearRect(0,0,can.width,can.height);
    asciiCtx.clearRect(0,0,asciiCanvas.width,asciiCanvas.height);

    const provider = aiProvider.value;
    const key = aiApiKey.value.trim();
    const shouldEnhance = aiEnhance.checked;
    const style = aiStyle.value;

    try {
        let currentPrompt = prompt;
        if (style) currentPrompt += ", " + style;

        // 1. Enhance Prompt
        if (shouldEnhance) {
             status.textContent = "Enhancing Prompt...";
             aiStatusDetail.textContent = "Enhancing prompt with " + provider + "...";
             try {
                currentPrompt = await enhancePrompt(currentPrompt, provider, key);
                aiStatusDetail.textContent = "Enhanced: " + currentPrompt;
             } catch (e) {
                console.error(e);
                aiStatusDetail.textContent = "Enhancement failed: " + e.message + ". Using original.";
             }
        }

        // 2. Generate Image URL
        status.textContent = "Generating Image...";
        let imageUrl = "";
        if (provider === 'openai') {
             if (!key) throw new Error("API Key required for OpenAI");
             const res = await fetch('https://api.openai.com/v1/images/generations', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${key}`
                },
                body: JSON.stringify({
                    prompt: currentPrompt,
                    n: 1,
                    size: "512x512"
                })
             });
             const data = await res.json();
             if(data.error) throw new Error(data.error.message);
             imageUrl = data.data[0].url;
        } else if (provider === 'mock') {
            imageUrl = "https://placehold.co/512x512?text=Mock+AI";
        } else {
             // Pollinations
             imageUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(currentPrompt)}`;
        }

        // 3. Process Image
        status.textContent = "Loading Image...";
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = imageUrl;

        img.onload = () => {
            status.textContent = "Converting to ASCII...";

            const wVal = parseInt(widthInput.value);
            const font = parseInt(fontInput.value);
            const bg = bgInput.value;
            const txt = txtInput.value;

            // Resize intermediate canvas
            can.width = wVal;
            const ratio = img.height / img.width;
            can.height = Math.floor(wVal * ratio / 2);

            ctx.drawImage(img, 0, 0, can.width, can.height);
            const frame = ctx.getImageData(0, 0, can.width, can.height);

            const txtContent = frameToASCII(frame);

            // Display logic
            asciiOut.style.display = 'inline-block';
            asciiCanvas.style.display = 'none';
            asciiOut.style.fontSize = font + "px";
            asciiOut.style.background = bg;
            asciiOut.style.color = txt;
            asciiOut.textContent = txtContent;

            status.textContent = "AI Art Generated! You can now download the text.";
            aiDownload.style.display = 'inline-block';
        };

        img.onerror = () => {
            status.textContent = "Error loading image (CORS or Network).";
            console.error("Image load error");
        };

    } catch (e) {
        console.error(e);
        status.textContent = "AI Generation failed: " + e.message;
    }
};

aiDownload.onclick = () => {
    const text = asciiOut.textContent;
    if (!text) return;
    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ai_ascii_art.txt';
    a.click();
    URL.revokeObjectURL(url);
};

function renderLoop() {
  if (!running || vid.paused || vid.ended) return;

  const wVal = parseInt(widthInput.value);
  const font = parseInt(fontInput.value);
  const fpsVal = parseInt(fpsInput.value);
  const effect = fxSelect.value;
  const res = resolution.value;
  const bg = bgInput.value;
  const txt = txtInput.value;

  // Resize intermediate canvas
  if (can.width !== wVal) can.width = wVal;
  const ratio = vid.videoHeight / vid.videoWidth;
  can.height = Math.floor(wVal * ratio / 2);

  ctx.drawImage(vid, 0, 0, can.width, can.height);
  const frame = ctx.getImageData(0, 0, can.width, can.height);
  const asciiText = frameToASCII(frame);

  renderASCII(asciiText, wVal, font, bg, txt, effect, res);

  setTimeout(() => requestAnimationFrame(renderLoop), 1000 / fpsVal);
}

function renderASCII(text, cols, fontSize, bgColor, txtColor, effect, res) {
  const isRecording = recorder && recorder.state === 'recording';

  // Use <pre> for dynamic resolution with no effects (performance), ONLY if not recording
  if (!isRecording && res === 'dynamic' && effect === 'none') {
    asciiCanvas.style.display = 'none';
    asciiOut.style.display = 'inline-block';

    asciiOut.style.fontSize = fontSize + "px";
    if (schemeSelect.value === 'rainbow') {
       asciiOut.classList.add('rainbow');
       asciiOut.style.background = '';
       asciiOut.style.backgroundColor = bgColor;
    } else {
       asciiOut.classList.remove('rainbow');
       asciiOut.style.background = bgColor;
       asciiOut.style.color = txtColor;
    }
    asciiOut.textContent = text;
    return;
  }

  // Use Canvas
  asciiOut.style.display = 'none';
  asciiCanvas.style.display = 'block';

  let targetW, targetH;

  // Determine target dimensions
  if (res === 'dynamic') {
      // Measure using the requested font size
      asciiCtx.font = fontSize + "px monospace";
      const metrics = asciiCtx.measureText("W");
      const charW = metrics.width;
      const charH = fontSize * 0.6;
      const lines = text.split('\n');
      targetW = Math.ceil(cols * charW);
      targetH = Math.ceil(lines.length * charH);
  } else {
      if (res === '480p') { targetW = 854; targetH = 480; }
      else if (res === '720p') { targetW = 1280; targetH = 720; }
      else if (res === '1080p') { targetW = 1920; targetH = 1080; }
  }

  if (asciiCanvas.width !== targetW || asciiCanvas.height !== targetH) {
      asciiCanvas.width = targetW;
      asciiCanvas.height = targetH;
  }

  // Draw
  const drawnMetrics = drawAsciiToCanvas(text, asciiCanvas, bgColor, txtColor, res === 'dynamic' ? fontSize : null);

  // Effects
  if (effect !== 'none') {
      const { charW, charH } = drawnMetrics;
      if (effect === 'matrix') applyMatrixEffect(asciiCanvas.width, asciiCanvas.height, charW, charH);
      else if (effect === 'glitch') applyGlitchEffect(asciiCanvas.width, asciiCanvas.height);
      else if (effect === 'oldtv') applyOldTVEffect(asciiCanvas.width, asciiCanvas.height);
  }
}

function drawAsciiToCanvas(text, canvas, bgColor, txtColor, forceFontSize) {
  const ctx = canvas.getContext('2d');
  const lines = text.split('\n');
  const cols = lines[0].length;

  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  let fontSize = forceFontSize;
  if (!fontSize) {
      // Calculate font size to fit width
      const charW = canvas.width / cols;
      fontSize = charW / 0.6; // approx
  }

  ctx.font = fontSize + "px monospace";
  ctx.textBaseline = "top";

  // Handle Rainbow
  if (schemeSelect.value === 'rainbow') {
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
      gradient.addColorStop(0, "red");
      gradient.addColorStop(0.14, "orange");
      gradient.addColorStop(0.28, "yellow");
      gradient.addColorStop(0.42, "lime");
      gradient.addColorStop(0.57, "blue");
      gradient.addColorStop(0.71, "indigo");
      gradient.addColorStop(0.85, "violet");
      ctx.fillStyle = gradient;
  } else {
      ctx.fillStyle = txtColor;
  }

  const metrics = ctx.measureText("W");
  const charW = metrics.width;
  const charH = fontSize * 0.6;

  for (let i = 0; i < lines.length; i++) {
    ctx.fillText(lines[i], 0, i * charH);
  }

  return { charW, charH };
}

function applyMatrixEffect(w, h, charW, charH) {
  const cols = Math.floor(w / charW);
  if (effectState.matrix.drops.length !== cols) {
      effectState.matrix.drops = new Array(cols).fill(0).map(() => Math.random() * h);
  }

  for (let i = 0; i < cols; i++) {
      const x = i * charW;
      const y = effectState.matrix.drops[i];

      // Random character
      const char = String.fromCharCode(0x30A0 + Math.random() * 96);

      asciiCtx.fillStyle = '#fff';
      asciiCtx.fillText(char, x, y);

      asciiCtx.fillStyle = 'rgba(0, 255, 0, 0.5)';
      asciiCtx.fillText(char, x, y - charH);

      if (y > h && Math.random() > 0.975) {
          effectState.matrix.drops[i] = 0;
      } else {
          effectState.matrix.drops[i] += charH;
      }
  }
}

function applyGlitchEffect(w, h) {
  if (Math.random() < 0.1) {
      const sliceH = Math.random() * 50 + 10;
      const sliceY = Math.random() * h;
      const offset = Math.random() * 20 - 10;

      asciiCtx.drawImage(asciiCanvas, 0, sliceY, w, sliceH, offset, sliceY, w, sliceH);

      if (Math.random() < 0.3) {
          asciiCtx.globalCompositeOperation = 'difference';
          asciiCtx.fillStyle = 'white';
          asciiCtx.fillRect(0, sliceY, w, 5);
          asciiCtx.globalCompositeOperation = 'source-over';
      }
  }
}

function applyOldTVEffect(w, h) {
  asciiCtx.fillStyle = "rgba(0,0,0,0.1)";
  for (let y = 0; y < h; y += 4) {
      asciiCtx.fillRect(0, y, w, 2);
  }
  const grad = asciiCtx.createRadialGradient(w/2, h/2, h/3, w/2, h/2, h);
  grad.addColorStop(0, "rgba(0,0,0,0)");
  grad.addColorStop(1, "rgba(0,0,0,0.6)");
  asciiCtx.fillStyle = grad;
  asciiCtx.fillRect(0, 0, w, h);
}

recBtn.onclick = async () => {
  if (!running) {
      alert("Please start the video first.");
      return;
  }

  if (recorder && recorder.state === "recording") {
      recorder.stop();
      recBtn.textContent = "Record";
      recBtn.style.background = "#111";
      recBtn.style.color = "#0f0";
      return;
  }

  // Start Recording
  try {
      const fps = parseInt(fpsInput.value);
      // We rely on renderASCII to switch to canvas mode if needed
      // But we need to grab the stream from the canvas
      stream = asciiCanvas.captureStream(fps);

      // Audio
      if (keepAudio.checked) {
          try {
              let audioStream = vid.captureStream ? vid.captureStream() : vid.mozCaptureStream();
              if (audioStream) {
                  const audioTracks = audioStream.getAudioTracks();
                  if (audioTracks.length > 0) {
                      stream.addTrack(audioTracks[0]);
                  }
              }
          } catch(e) {
              console.warn("Audio capture failed", e);
          }
      }

      recorder = new MediaRecorder(stream, { mimeType: "video/webm" });
      chunks = [];
      recorder.ondataavailable = e => { if(e.data.size > 0) chunks.push(e.data); };
      recorder.onstop = saveRecording;

      recorder.start();
      recBtn.textContent = "Recording...";
      recBtn.style.background = "#f00";
      recBtn.style.color = "#fff";
      status.textContent = "Recording started...";

  } catch(e) {
      console.error(e);
      alert("Recording failed: " + e.message);
  }
};

async function saveRecording() {
  const blob = new Blob(chunks, { type: "video/webm" });
  const url = URL.createObjectURL(blob);

  // Download WebM
  const a = document.createElement("a");
  a.href = url;
  a.download = "ascii_video.webm";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  status.textContent = "Saved .webm. Converting to MP4...";

  try {
      if (typeof FFmpeg === 'undefined') throw new Error("FFmpeg not loaded");
      const ffmpeg = createFFmpeg({ log: true });
      await ffmpeg.load();

      await ffmpeg.FS('writeFile', 'input.webm', await fetchFile(blob));
      await ffmpeg.run('-i', 'input.webm', '-c:v', 'libx264', '-preset', 'ultrafast', 'output.mp4');

      const data = ffmpeg.FS('readFile', 'output.mp4');
      const mp4Blob = new Blob([data.buffer], { type: 'video/mp4' });
      const mp4Url = URL.createObjectURL(mp4Blob);

      const b = document.createElement("a");
      b.href = mp4Url;
      b.download = "ascii_video.mp4";
      document.body.appendChild(b);
      b.click();
      document.body.removeChild(b);

      status.textContent = "Saved .webm and .mp4!";
  } catch (e) {
      console.error(e);
      status.textContent = "Saved .webm. MP4 conversion failed: " + e.message;
  }
}

</script>
</body>
</html>