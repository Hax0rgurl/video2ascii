<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Video2ASCII â€” Final Local Build</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<style>
  body {
    background:#000;
    color:#0f0;
    font-family:monospace;
    text-align:center;
    margin:0;
    padding:1em;
  }
  h1, h2{margin:0.2em 0;}
  .controls{
    display:flex;flex-wrap:wrap;justify-content:center;gap:0.5em;margin-bottom:1em;
  }
  label{color:#0f0;}
  input,select,button{
    background:#111;color:#0f0;border:1px solid #0f0;
    font-family:monospace;padding:0.3em 0.6em;
  }
  button:hover,input:hover,select:hover{background:#0f0;color:#000;}
  video{max-width:45%;border:1px solid #0f0;}
  pre{
    display:inline-block;background:#000;color:#0f0;border:1px solid #0f0;
    white-space:pre;line-height:0.6em;font-size:10px;text-align:center;
    overflow:hidden;max-width:45%;
  }
  .display{display:flex;justify-content:center;align-items:flex-start;gap:1em;flex-wrap:wrap;}
  #status{margin-top:0.5em;color:#0f0;}
</style>
</head>
<body>
<h1>ðŸŽ¥ Video â†’ ASCII</h1>

<div class="controls">
  <input type="file" id="file" accept="video/mp4,video/webm">
  <label>Width:<input type="number" id="width" value="100" min="40" max="200"></label>
  <label>FPS:<input type="number" id="fps" value="15" min="5" max="60"></label>
  <label>Font:<input type="number" id="fontsize" value="10" min="6" max="20"></label>
  <label>Color Scheme:
    <select id="scheme">
      <option value="matrix">Matrix Green</option>
      <option value="cyber">Cyberpunk Neon</option>
      <option value="amber">Retro Amber</option>
      <option value="pastel">Soft Pastel</option>
      <option value="rainbow">Rainbow</option>
    </select>
  </label>
  <label>BG:<input type="color" id="bg" value="#000000"></label>
  <label>Text:<input type="color" id="txt" value="#00ff00"></label>
  <label>Effect:
    <select id="fx">
      <option value="none">None</option>
      <option value="matrix">Matrix Rain</option>
      <option value="glitch">Glitch</option>
      <option value="oldtv">Old TV</option>
    </select>
  </label>
  <button id="start">Convert</button>
  <button id="record">Record</button>
  <button id="stop">Stop</button>
</div>

<h2>ðŸ¤– AI ASCII Art Generator</h2>
<div class="controls">
  <input type="text" id="ai-prompt" placeholder="Enter text prompt..." style="width: 200px;">
  <select id="ai-style">
    <option value="">Default Style</option>
    <option value="minimalist line art">Minimalist</option>
    <option value="highly detailed, intricate">Detailed</option>
    <option value="cyberpunk, neon">Cyberpunk</option>
    <option value="retro computer graphics, 8-bit">Retro</option>
    <option value="sketch, pencil drawing">Sketch</option>
  </select>
  <button id="ai-generate">Generate AI Art</button>
</div>

<div class="controls" id="ai-settings">
  <label>Provider:
    <select id="ai-provider" onchange="toggleApiKey()">
      <option value="pollinations">Pollinations (Free)</option>
      <option value="openai">OpenAI (API Key)</option>
      <option value="mock">Mock (Test)</option>
    </select>
  </label>
  <input type="password" id="ai-api-key" placeholder="API Key (OpenAI)" style="display:none; width: 200px;">
  <label><input type="checkbox" id="ai-enhance" checked> Enhance Prompt</label>
</div>
<div id="ai-status-detail" style="color: #0f0; font-size: 0.8em; margin-bottom: 0.5em;"></div>

<div class="display">
  <video id="video" controls></video>
  <pre id="ascii"></pre>
</div>
<canvas id="canvas" style="display:none;"></canvas>
<p id="status"></p>

<!-- ffmpeg.wasm CDN -->
<script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.4/dist/ffmpeg.min.js"></script>

<script>
const chars="@#8&$%WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~<>i!lI;:,\"^`'. ";
const file=document.getElementById('file');
const vid=document.getElementById('video');
const can=document.getElementById('canvas');
const ctx=can.getContext('2d');
const asciiOut=document.getElementById('ascii');
const start=document.getElementById('start');
const stop=document.getElementById('stop');
const recBtn=document.getElementById('record');
const status=document.getElementById('status');

// AI Elements
const aiPrompt = document.getElementById('ai-prompt');
const aiStyle = document.getElementById('ai-style');
const aiGenerate = document.getElementById('ai-generate');
const aiProvider = document.getElementById('ai-provider');
const aiApiKey = document.getElementById('ai-api-key');
const aiEnhance = document.getElementById('ai-enhance');
const aiStatusDetail = document.getElementById('ai-status-detail');

function toggleApiKey() {
    aiApiKey.style.display = (aiProvider.value === 'openai') ? 'inline-block' : 'none';
}

async function enhancePrompt(prompt, provider, apiKey) {
    if (provider === 'mock') {
        return "Mock Enhanced: " + prompt;
    }

    if (provider === 'pollinations') {
        try {
            const response = await fetch(`https://text.pollinations.ai/${encodeURIComponent("Enhance this image prompt: " + prompt)}`);
            if (!response.ok) throw new Error("Pollinations Text API error: " + response.status);
            const text = await response.text();
            return text.trim();
        } catch (e) {
            console.warn("Pollinations text enhancement failed:", e);
            aiStatusDetail.textContent = "Pollinations Text API failed, using original prompt.";
            return prompt;
        }
    }

    if (provider === 'openai') {
        if (!apiKey) {
            alert("Please enter an OpenAI API Key.");
            throw new Error("Missing API Key");
        }
        try {
            const response = await fetch("https://api.openai.com/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: "gpt-3.5-turbo",
                    messages: [
                        {role: "system", content: "You are an artistic prompt engineer. Rewrite the user's prompt to be more descriptive and suitable for an AI image generator. Output ONLY the enhanced prompt, no explanations."},
                        {role: "user", content: prompt}
                    ],
                    max_tokens: 150
                })
            });
            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error?.message || "OpenAI API error");
            }
            const data = await response.json();
            return data.choices[0].message.content.trim();
        } catch (e) {
            console.error("OpenAI enhancement failed:", e);
            aiStatusDetail.textContent = "OpenAI enhancement failed: " + e.message;
            throw e;
        }
    }

    return prompt;
}

async function generateImage(prompt, style, provider, apiKey) {
    const finalPrompt = style ? `${prompt}, ${style}` : prompt;
    const seed = Math.floor(Math.random() * 10000);

    if (provider === 'mock') {
        return `https://placehold.co/600x400/000000/00ff00?text=${encodeURIComponent(prompt.substring(0, 20))}`;
    }

    if (provider === 'pollinations') {
        return `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}?seed=${seed}&nologo=true`;
    }

    if (provider === 'openai') {
        if (!apiKey) throw new Error("Missing API Key for OpenAI Image Generation");
        try {
            const response = await fetch("https://api.openai.com/v1/images/generations", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    prompt: finalPrompt,
                    n: 1,
                    size: "512x512",
                    response_format: "url"
                })
            });
            if (!response.ok) {
                 const err = await response.json();
                 throw new Error(err.error?.message || "OpenAI Image API error");
            }
            const data = await response.json();
            return data.data[0].url;
        } catch (e) {
            console.error("OpenAI image generation failed:", e);
            throw e;
        }
    }

    return `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}?seed=${seed}&nologo=true`;
}

// Controls for settings
const widthInput = document.getElementById('width');
const fpsInput = document.getElementById('fps');
const fontInput = document.getElementById('fontsize');
const bgInput = document.getElementById('bg');
const txtInput = document.getElementById('txt');

let running=false, recorder=null, chunks=[], stream=null;

file.onchange=e=>{
  const f=e.target.files[0];
  if(f){vid.src=URL.createObjectURL(f);vid.load();status.textContent="Video loaded";}
};

start.onclick=()=>{if(!vid.src)return alert("Load a video");running=true;vid.play();renderLoop();};

stop.onclick=()=>{
  running=false;vid.pause();
  if(recorder&&recorder.state==="recording")recorder.stop();
  status.textContent="Stopped.";
};

function renderLoop(){
  if(!running||vid.paused||vid.ended)return;
  const width=parseInt(widthInput.value);
  const font=parseInt(fontInput.value);
  const fps=parseInt(fpsInput.value);
  asciiOut.style.fontSize=font+"px";
  asciiOut.style.background=bgInput.value;
  asciiOut.style.color=txtInput.value;

  can.width=width;
  const ratio=vid.videoHeight/vid.videoWidth;
  can.height=Math.floor(width*ratio/2);

  ctx.drawImage(vid,0,0,can.width,can.height);
  const frame=ctx.getImageData(0,0,can.width,can.height);
  asciiOut.textContent=frameToASCII(frame);
  setTimeout(()=>requestAnimationFrame(renderLoop),1000/fps);
}

function frameToASCII(frame){
  const p=frame.data,w=frame.width,h=frame.height;let out="";
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const i=(y*w+x)*4;
      const r=p[i],g=p[i+1],b=p[i+2];
      const bright=(0.299*r+0.587*g+0.114*b)/255;
      const idx=Math.floor((1-bright)*(chars.length-1));
      out+=chars[idx];
    }
    out+="\n";
  }
  return out;
}

// AI Generation Logic
aiGenerate.onclick = async () => {
    const prompt = aiPrompt.value.trim();
    if (!prompt) return alert("Please enter a prompt");

    if (running) {
         running = false;
         vid.pause();
    }

    status.textContent = "Initiating AI...";
    aiStatusDetail.textContent = "Starting...";
    asciiOut.textContent = "Processing...";

    const provider = aiProvider.value;
    const key = aiApiKey.value.trim();
    const shouldEnhance = aiEnhance.checked;
    const style = aiStyle.value;

    try {
        let currentPrompt = prompt;

        // 1. Enhance Prompt
        if (shouldEnhance) {
             status.textContent = "Enhancing Prompt...";
             aiStatusDetail.textContent = "Enhancing prompt with " + provider + "...";
             currentPrompt = await enhancePrompt(prompt, provider, key);
             aiStatusDetail.textContent = "Enhanced: " + currentPrompt;
        }

        // 2. Generate Image
        status.textContent = "Generating Image...";
        const imageUrl = await generateImage(currentPrompt, style, provider, key);

        // 3. Process Image
        status.textContent = "Loading Image...";
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.src = imageUrl;

        img.onload = () => {
            status.textContent = "Converting to ASCII...";

            const width = parseInt(widthInput.value);
            const font = parseInt(fontInput.value);

            asciiOut.style.fontSize = font + "px";
            asciiOut.style.background = bgInput.value;
            asciiOut.style.color = txtInput.value;

            const ratio = img.height / img.width;
            can.width = width;
            can.height = Math.floor(width * ratio / 2);

            ctx.drawImage(img, 0, 0, can.width, can.height);
            const frame = ctx.getImageData(0, 0, can.width, can.height);
            asciiOut.textContent = frameToASCII(frame);

            status.textContent = "AI Art Generated!";
        };

        img.onerror = () => {
            status.textContent = "Error loading image.";
            aiStatusDetail.textContent = "Failed to load image from URL: " + imageUrl;
        };

    } catch (e) {
        status.textContent = "Error: " + e.message;
        aiStatusDetail.textContent = "Error: " + e.message;
        console.error(e);
    }
};

// Recording
recBtn.onclick=async()=>{
  if(!running)start.click();
  if(recorder&&recorder.state==="recording")return;
  // This might fail if browser doesn't support captureStream on Pre
  try {
    stream=asciiOut.captureStream(parseInt(fpsInput.value));
    recorder=new MediaRecorder(stream,{mimeType:"video/webm"});
    chunks=[];
    recorder.ondataavailable=e=>chunks.push(e.data);
    recorder.onstop=saveRecording;
    recorder.start();
    status.textContent="Recording ASCII...";
    vid.onended=()=>recorder.stop();
  } catch(e) {
      console.error(e);
      status.textContent = "Recording not supported on this browser.";
      alert("Recording is not supported in this environment.");
  }
};

// Save .webm and optionally convert to .mp4
async function saveRecording(){
  const blob=new Blob(chunks,{type:"video/webm"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url;a.download="ascii_video.webm";a.click();
  status.textContent="Saved ascii_video.webm";

  // Optional MP4 conversion
  try {
      if(typeof FFmpeg === 'undefined') throw new Error("FFmpeg not loaded");
      const ffmpeg=FFmpeg.createFFmpeg({log:false});
      await ffmpeg.load();
      await ffmpeg.FS('writeFile','input.webm',await fetchFile(blob));
      await ffmpeg.run('-i','input.webm','-c:v','libx264','output.mp4');
      const data=ffmpeg.FS('readFile','output.mp4');
      const mp4URL=URL.createObjectURL(new Blob([data.buffer],{type:'video/mp4'}));
      const b=document.createElement('a');
      b.href=mp4URL;b.download='ascii_video.mp4';b.click();
      status.textContent+=" and ascii_video.mp4";
  } catch(e) {
      console.log("FFmpeg conversion failed or skipped:", e);
  }
}
</script>
</body>
</html>
